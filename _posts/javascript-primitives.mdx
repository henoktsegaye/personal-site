---
date: "2021-03-28"
thumbnail: /assets/javascript-primitives.png
title: Understanding Javascript primitive types
description: Javascript Primitive types are the basic building blocks of Javascript. We will try to understand how they work.
hashtag: Javascript
---
Welcome to the **Understanding Javascript basics** series, on this blog we will try to understand primitive types in Javascript. 

let's get to it üôÇ

---


Javascript has primitive types ( primitive value ) that are directly represented at the lowest level of the language implementation.
Javascript in general has two types of data types - **primitive** and **non-primitive** (Object).
every other data type in javascript is an object. Functions, classes, or arrays are all objects.
you can tell this by just looking at the **typeof** operator which might not be accurate at time but it's a good enough approximation.

```
typeof 'hello' // string
typeof true // boolean
typeof 1 // number
typeof {} // object
typeof null // object
typeof undefined // undefined
typeof function () {} // function
typeof Symbol('hello') // symbol
```

But here `typeof null` is an object which is not actully true since null is a primitive type.

```
typeof null // object
```

this is considered a bug in javascript.
Javascript primitives types are not objects and their value are immutable. but variables can be reassigned to a new value.
doing so will create a new variable and garbage collector will clean up the old one.

example of primitive type immutablity
```
let a = 1;
let b = a;
// changing a will not change b
a = 2;
console.log(a); // 2
console.log(b); // 1
```
As both `a` and `b` are primitive types, they are not related to each other.
when copying `b` from `a` Javascript **will copy the value of `a` and assign it to `b`** , so changing one will not change the other.

Comparing primitive types to object üëáüèæ
```
let a = {
    value: 1
};
let b = a;
// changing a will change b as they have the same reference
a.value = 2;
console.log(a.value); // 2
console.log(b.value); // 2
``` 
As you can see in the above example, Objects doesn't hold values but references so, changing `a` will change `b ` as they have the same reference.

well if primitives are not Objects you might ask how are we accessing properties off them like this example below ?
```
'hello'.length // 5
```

<img src="https://media.giphy.com/media/3o7btPCcdNniyf0ArS/giphy.gif" />
<br />
This is not a bug in javascript üòÑ

This is actully one of the features of javascript. 

Primitives are not Objects but they **act like they are** ü§î ? Well here is how it works

Javascript maps out primitive types to **_Wrapper Objects_** which is the reason we can see the `length` property of a string.
Which will actully create a new object with value `"hello"`, so you can access the length property ( or anyother String proprety ) off that object. This is actully true for Other two Primitive types **Boolean** and **Number** .

```
let strObj = new String('hello')
typeof strObj // object
strObj.length // 5

// access the value of the object , which is the primitive value
strObj.valueOf() // hello
typeof strObj.valueOf() // string
```

Boolean Object
```
let boolObj = new Boolean(true)
typeof boolObj // object
boolObj.valueOf() // true
typeof boolObj.valueOf() // boolean
```
Number Object
```
let numObj = new Number(1)
typeof numObj // object
numObj.toFixed(2) // 1.00

numObj.valueOf() // 1
typeof numObj.valueOf() // number
```

But once we had access the property of the object Garbage Collector will remove the object from memory.

Javascript has 7 primitive types:

- undefined
- null
- boolean
- number
- string
- symbol - es2015
- bigint - es2020


The `symbol` data type is new in es6.
`bigint` is new in es2020.

we will dive deep into these primitive types in the next blog in this series.

